/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => StudyAnalyticsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var VIEW_TYPE_STUDY_FLOW = "study-flow-view";
var DEFAULT_SETTINGS = {
  pomodoroTime: 25,
  shortBreakTime: 5,
  longBreakTime: 15,
  longBreakInterval: 4,
  notesFolder: "Study Sessions",
  focusPath: "",
  categories: ["Study", "Work", "Reading", "Project", "~Break~"],
  tags: ["#important", "#question", "#difficult", "#review"],
  autoStartBreaks: true,
  autoStartPomodoros: false,
  showDifficulty: true,
  trackModifiedFiles: true,
  enableWeeklySummary: true,
  weeklySummaryDay: 0,
  // Sunday by default
  createDailySummary: true,
  trackOpenedFiles: true,
  trackWordCount: true,
  resetTimerOnNewSession: false,
  autoTrackSessionOnStartup: false,
  autoSetCategoryByFolder: false,
  folderCategoryMappings: {},
  preserveTempFiles: true,
  tagsToTrack: [],
  trackCreatedNotes: true,
  trackWithoutSession: false,
  // Track Obsidian usage without explicit session (until 23:59)
  autoDailySummary: false,
  // Automatically create daily summary at midnight
  autoWeeklySummary: false,
  // Automatically create weekly summary on specified day
  keepLongTermData: true,
  // Keep session data long-term instead of deleting after summaries
  trackTaggedNotes: false
  // Track notes with specific tags
};
var StudySession = class {
  constructor(category) {
    this.category = category;
    this.startTime = /* @__PURE__ */ new Date();
    this.endTime = null;
    this.pomodorosCompleted = 0;
    this.difficulty = 1;
    this.notes = "";
    this.distractions = [];
    this.lineNotes = [];
    this.modifiedFiles = /* @__PURE__ */ new Set();
    this.openedFiles = /* @__PURE__ */ new Set();
    this.createdFiles = /* @__PURE__ */ new Set();
    this.completed = false;
    this.completedTasks = [];
    this.reflections = [];
    this.pauseStartTime = null;
    this.totalPauseDuration = 0;
    this.isBreak = category === "~Break~";
    this.wordCount = 0;
    this.initialWordCounts = /* @__PURE__ */ new Map();
    this.createdLinks = /* @__PURE__ */ new Set();
    this.initialLinkCounts = /* @__PURE__ */ new Map();
  }
  pause() {
    if (!this.pauseStartTime) {
      this.pauseStartTime = /* @__PURE__ */ new Date();
    }
  }
  resume() {
    if (this.pauseStartTime) {
      this.totalPauseDuration += Number(/* @__PURE__ */ new Date()) - Number(this.pauseStartTime);
      this.pauseStartTime = null;
    }
  }
  addDistraction(note) {
    this.distractions.push({
      time: /* @__PURE__ */ new Date(),
      note
    });
  }
  addLineNote(line, file, tag, note, lineNumber) {
    this.lineNotes.push({
      time: /* @__PURE__ */ new Date(),
      line,
      file,
      tag,
      note,
      lineNumber
    });
  }
  addReflection(text) {
    this.reflections.push({
      time: /* @__PURE__ */ new Date(),
      text
    });
  }
  addCompletedTask(task) {
    this.completedTasks.push({
      time: /* @__PURE__ */ new Date(),
      task
    });
  }
  trackModifiedFile(file) {
    this.modifiedFiles.add(file);
  }
  trackOpenedFile(file) {
    this.openedFiles.add(file);
  }
  updateWordCount(filePath, currentWordCount) {
    if (!this.initialWordCounts.has(filePath)) {
      this.initialWordCounts.set(filePath, currentWordCount);
      return;
    }
    const initialCount = this.initialWordCounts.get(filePath) || 0;
    if (currentWordCount > initialCount) {
      this.wordCount += currentWordCount - initialCount;
      this.initialWordCounts.set(filePath, currentWordCount);
    }
  }
  trackCreatedFile(file) {
    this.createdFiles.add(file);
  }
  updateLinkCount(filePath, currentLinkCount) {
    if (!this.initialLinkCounts.has(filePath)) {
      this.initialLinkCounts.set(filePath, currentLinkCount);
      return;
    }
    const initialCount = this.initialLinkCounts.get(filePath) || 0;
    if (currentLinkCount > initialCount) {
      const newLinks = currentLinkCount - initialCount;
      for (let i = 0; i < newLinks; i++) {
        this.createdLinks.add(`${filePath}:${initialCount + i + 1}`);
      }
      this.initialLinkCounts.set(filePath, currentLinkCount);
    }
  }
  getDuration() {
    const end = this.endTime || /* @__PURE__ */ new Date();
    let duration = Math.round((Number(end) - Number(this.startTime)) / 6e4);
    if (this.pauseStartTime) {
      duration -= Math.round((Number(/* @__PURE__ */ new Date()) - Number(this.pauseStartTime)) / 6e4);
    }
    duration -= Math.round(this.totalPauseDuration / 6e4);
    return Math.max(0, duration);
  }
  end() {
    this.endTime = /* @__PURE__ */ new Date();
    return {
      category: this.category,
      startTime: this.startTime,
      duration: this.getDuration(),
      pomodoros: this.pomodorosCompleted,
      difficulty: this.difficulty,
      notes: this.notes,
      distractions: this.distractions,
      lineNotes: this.lineNotes,
      modifiedFiles: Array.from(this.modifiedFiles),
      openedFiles: Array.from(this.openedFiles),
      createdFiles: Array.from(this.createdFiles),
      completedTasks: this.completedTasks,
      reflections: this.reflections,
      date: this.startTime.toISOString().split("T")[0],
      completed: this.completed,
      isBreak: this.isBreak,
      pauseDuration: Math.round(this.totalPauseDuration / 6e4),
      wordCount: this.wordCount,
      createdLinks: Array.from(this.createdLinks)
    };
  }
};
var StudyFlowView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.timeLeft = this.plugin.settings.pomodoroTime * 60;
    this.isRunning = false;
    this.isBreak = false;
    this.pomodoroCount = 0;
    this.timerStartTime = null;
    this.lastUpdate = null;
    this.isStopwatch = false;
    this.stopwatchStartTime = null;
    this.stopwatchElapsed = 0;
    this.interval = null;
  }
  getViewType() {
    return VIEW_TYPE_STUDY_FLOW;
  }
  getDisplayText() {
    return "Study Flow";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    const dailyStatsContainer = container.createEl("div", {
      cls: "study-flow-daily-stats"
    });
    this.dailyTimeDisplay = dailyStatsContainer.createEl("div", {
      cls: "study-flow-daily-time",
      text: "Today's Study Time: Loading..."
    });
    await this.updateDailyTime();
    this.registerInterval(
      window.setInterval(async () => await this.updateDailyTime(), 6e4)
    );
    this.timerDisplay = container.createEl("div", { cls: "timer-display" });
    this.endTimeDisplay = container.createEl("div", { cls: "end-time-display" });
    this.updateTimerDisplay();
    const stopwatchDiv = container.createEl("div", { cls: "stopwatch-section" });
    this.stopwatchToggle = stopwatchDiv.createEl("button", {
      text: "Switch to Stopwatch",
      cls: "stopwatch-toggle"
    });
    this.stopwatchToggle.onclick = () => this.toggleStopwatchMode();
    const controls = container.createEl("div", { cls: "controls" });
    this.startButton = controls.createEl("button", {
      text: "Start",
      cls: "control-button start-button"
    });
    this.startButton.onclick = () => this.toggleTimer();
    const newSessionButton = controls.createEl("button", {
      text: "New Session",
      cls: "control-button new-session-button"
    });
    newSessionButton.onclick = async () => {
      if (this.plugin.currentSession) {
        this.plugin.currentSession.notes = this.notesArea.value;
        if (this.plugin.settings.showDifficulty) {
          this.plugin.currentSession.difficulty = parseInt(this.difficultySlider.value);
        }
        const sessionData = this.plugin.currentSession.end();
        await this.plugin.saveSessionToFile(sessionData);
      }
      const category = this.categorySelect.value;
      this.plugin.startNewSession(category);
      this.notesArea.value = "";
      this.distractionInput.value = "";
      if (this.difficultySlider) {
        this.difficultySlider.value = "1";
      }
      if (this.plugin.settings.resetTimerOnNewSession) {
        if (!this.isStopwatch) {
          this.timeLeft = this.plugin.settings.pomodoroTime * 60;
        } else {
          this.stopwatchElapsed = 0;
          this.stopwatchStartTime = null;
        }
        const wasRunning = this.isRunning;
        if (wasRunning) {
          this.pauseTimer();
          this.startTimer();
        }
        this.updateTimerDisplay();
        new import_obsidian.Notice("New session started - Timer reset");
      } else {
        new import_obsidian.Notice("New session started - Timer continues");
      }
    };
    const endButton = controls.createEl("button", {
      text: "End",
      cls: "control-button end-button"
    });
    endButton.onclick = () => this.plugin.endCurrentSession();
    const categoryDiv = container.createEl("div", { cls: "category-section" });
    categoryDiv.createEl("label", { text: "Category: " });
    this.categorySelect = categoryDiv.createEl("select");
    this.categorySelect.onchange = () => {
      this.changeCategory(this.categorySelect.value);
    };
    this.updateCategorySelect();
    if (this.plugin.settings.showDifficulty) {
      const difficultyDiv = container.createEl("div", { cls: "difficulty-section" });
      difficultyDiv.createEl("label", { text: "Difficulty: " });
      this.difficultySlider = difficultyDiv.createEl("input", {
        type: "range",
        attr: {
          min: "1",
          max: "5",
          value: "1"
        },
        cls: "difficulty-slider"
      });
    }
    const notesDiv = container.createEl("div", { cls: "notes-section" });
    notesDiv.createEl("label", { text: "Session Notes:" });
    this.notesArea = notesDiv.createEl("textarea", {
      cls: "notes-area",
      attr: { rows: "4", placeholder: "Enter session notes here..." }
    });
    const reflectionDiv = container.createEl("div", { cls: "reflection-section" });
    const reflectionButton = reflectionDiv.createEl("button", {
      text: "Add Reflection",
      cls: "reflection-button"
    });
    reflectionButton.onclick = () => this.addReflection();
    const distractionDiv = container.createEl("div", { cls: "distraction-section" });
    const distractionButton = distractionDiv.createEl("button", {
      text: "Report Distraction",
      cls: "distraction-button"
    });
    this.distractionInput = distractionDiv.createEl("input", {
      type: "text",
      attr: {
        placeholder: "What distracted you?"
      },
      cls: "distraction-input"
    });
    distractionButton.onclick = () => this.reportDistraction();
    container.createEl("style").textContent = this.getStyles();
  }
  async updateDailyTime() {
    const today = (/* @__PURE__ */ new Date()).toLocaleDateString();
    let totalMinutes = 0;
    const tempFolderPath = `${this.plugin.settings.notesFolder}/temp`;
    try {
      if (await this.app.vault.adapter.exists(tempFolderPath)) {
        const tempFiles = await this.app.vault.adapter.list(tempFolderPath);
        for (const file of tempFiles.files) {
          const content = await this.app.vault.adapter.read(file);
          const sessionData = JSON.parse(content);
          const sessionDate = new Date(sessionData.startTime).toLocaleDateString();
          if (sessionDate === today && !sessionData.isBreak) {
            totalMinutes += sessionData.duration;
          }
        }
      }
      if (this.plugin.currentSession && !this.plugin.currentSession.isBreak) {
        totalMinutes += this.plugin.currentSession.getDuration();
      }
      const hours = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      this.dailyTimeDisplay.setText(`Today's Study Time: ${hours}h ${minutes}m`);
    } catch (error) {
      console.error("Error calculating total study time:", error);
      this.dailyTimeDisplay.setText("Today's Study Time: Error");
    }
  }
  getStyles() {
    return `
            .study-flow-daily-stats {
                background: var(--background-secondary);
                padding: 10px;
                border-radius: 5px;
                margin: 10px 20px;
                text-align: center;
            }
            
            .study-flow-daily-time {
                font-size: 1.2em;
                font-weight: bold;
                color: var(--text-accent);
            }

            .timer-display {
                font-size: 3em;
                text-align: center;
                margin: 20px;
                font-family: monospace;
            }
            .end-time-display {
                text-align: center;
                margin-top: -15px;
                margin-bottom: 20px;
                font-size: 0.9em;
                color: var(--text-muted);
            }
            .stopwatch-section {
                text-align: center;
                margin: 10px 0;
            }
            .stopwatch-toggle {
                padding: 5px 15px;
                margin: 5px;
            }
            .controls {
                text-align: center;
                margin: 20px;
                display: flex;
                justify-content: center;
                gap: 10px;
            }
            .control-button {
                padding: 5px 15px;
                min-width: 80px;
            }
            .end-button {
                background-color: #ff4444;
                color: white;
            }
            .category-section, .difficulty-section, 
            .reflection-section, .distraction-section, .notes-section {
                margin: 20px;
            }
            .notes-area, .distraction-input {
                width: 100%;
                margin-top: 10px;
            }
            .difficulty-slider {
                width: 200px;
            }
            .reflection-button {
                width: 100%;
                margin-top: 10px;
                padding: 5px;
            }
        `;
  }
  updateCategorySelect() {
    this.categorySelect.empty();
    this.plugin.settings.categories.forEach((cat) => {
      if (!this.isBreak || cat === "~Break~") {
        const option = this.categorySelect.createEl("option", {
          text: cat,
          value: cat
        });
        if (cat === "~Break~") {
          option.disabled = !this.isBreak;
        }
      }
    });
  }
  toggleStopwatchMode() {
    if (this.isRunning) {
      this.pauseTimer();
    }
    this.isStopwatch = !this.isStopwatch;
    this.stopwatchToggle.textContent = this.isStopwatch ? "Switch to Pomodoro" : "Switch to Stopwatch";
    this.resetSession();
    this.updateCategorySelect();
  }
  updateTimerDisplay() {
    if (this.isStopwatch) {
      const totalSeconds = Math.floor(this.stopwatchElapsed / 1e3);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      const display = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
      this.timerDisplay.textContent = display;
      this.endTimeDisplay.textContent = "";
    } else {
      const minutes = Math.floor(this.timeLeft / 60);
      const seconds = this.timeLeft % 60;
      const display = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
      this.timerDisplay.textContent = display;
      if (this.isRunning) {
        const endTime = new Date(Date.now() + this.timeLeft * 1e3);
        const endTimeStr = endTime.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
        this.endTimeDisplay.textContent = `Ends at ${endTimeStr}`;
      } else {
        this.endTimeDisplay.textContent = "";
      }
    }
    if (this.plugin) {
      this.plugin.updateStatusBar(this.timerDisplay.textContent);
    }
  }
  resetSession() {
    if (this.isStopwatch) {
      this.stopwatchElapsed = 0;
    } else {
      this.timeLeft = this.plugin.settings.pomodoroTime * 60;
      this.isBreak = false;
      this.pomodoroCount = 0;
    }
    this.isRunning = false;
    this.timerStartTime = null;
    this.lastUpdate = null;
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = null;
    }
    this.startButton.textContent = "Start";
    this.updateTimerDisplay();
    this.notesArea.value = "";
    this.distractionInput.value = "";
    if (this.difficultySlider) {
      this.difficultySlider.value = "1";
    }
    if (this.categorySelect && this.categorySelect.options.length > 0) {
      this.categorySelect.selectedIndex = 0;
    }
  }
  toggleTimer() {
    if (this.isRunning) {
      this.pauseTimer();
    } else {
      this.startTimer();
    }
  }
  changeCategory(newCategory) {
    if (this.plugin.currentSession && this.plugin.currentSession.category !== newCategory) {
      this.plugin.currentSession.notes = this.notesArea.value;
      if (this.plugin.settings.showDifficulty) {
        this.plugin.currentSession.difficulty = parseInt(this.difficultySlider.value);
      }
      const wasRunning = this.isRunning;
      const timeLeftBackup = this.timeLeft;
      const stopwatchElapsedBackup = this.stopwatchElapsed;
      const isStopwatchBackup = this.isStopwatch;
      if (wasRunning) {
        this.pauseTimer();
      }
      const sessionData = this.plugin.currentSession.end();
      this.plugin.saveSessionToFile(sessionData);
      this.plugin.startNewSession(newCategory);
      this.categorySelect.value = newCategory;
      if (this.difficultySlider) {
        this.difficultySlider.value = "1";
      }
      if (isStopwatchBackup) {
        this.stopwatchElapsed = stopwatchElapsedBackup;
      } else {
        this.timeLeft = timeLeftBackup;
      }
      if (wasRunning) {
        this.startTimer();
      }
      new import_obsidian.Notice(`Category changed to ${newCategory}`);
    }
  }
  startTimer() {
    if (!this.plugin.currentSession) {
      const category = this.categorySelect.value;
      this.plugin.startNewSession(category);
    }
    if (this.plugin.currentSession) {
      this.plugin.currentSession.resume();
    }
    this.isRunning = true;
    this.startButton.textContent = "Pause";
    if (this.isStopwatch) {
      if (!this.stopwatchStartTime) {
        this.stopwatchStartTime = Date.now() - this.stopwatchElapsed;
      }
      this.interval = window.setInterval(() => {
        this.stopwatchElapsed = Date.now() - this.stopwatchStartTime;
        this.updateTimerDisplay();
        this.updateDailyTime();
      }, 100);
    } else {
      if (!this.interval) {
        this.startTime = Date.now();
        this.endTime = this.startTime + this.timeLeft * 1e3;
        this.lastUpdate = this.startTime;
        this.interval = window.setInterval(() => {
          const now = Date.now();
          const elapsed = now - this.lastUpdate;
          if (elapsed > 2e3) {
            this.timeLeft = Math.max(0, Math.ceil((this.endTime - now) / 1e3));
          } else {
            const remaining = Math.max(0, Math.ceil((this.endTime - now) / 1e3));
            if (remaining !== this.timeLeft) {
              this.timeLeft = remaining;
            }
          }
          this.lastUpdate = now;
          this.updateTimerDisplay();
          this.updateDailyTime();
          if (this.timeLeft <= 0) {
            this.completeTimer();
          }
        }, 100);
      }
    }
  }
  pauseTimer() {
    this.isRunning = false;
    this.startButton.textContent = "Start";
    if (this.plugin.currentSession) {
      this.plugin.currentSession.pause();
    }
    if (this.interval) {
      window.clearInterval(this.interval);
      this.interval = null;
    }
    if (!this.isStopwatch) {
      const now = Date.now();
      this.timeLeft = Math.max(0, Math.ceil((this.endTime - now) / 1e3));
    }
    this.endTimeDisplay.textContent = "";
    this.updateDailyTime();
  }
  async completeTimer() {
    this.pauseTimer();
    if (!this.isBreak) {
      this.pomodoroCount++;
      if (this.plugin.currentSession) {
        this.plugin.currentSession.notes = this.notesArea.value;
        if (this.plugin.settings.showDifficulty) {
          this.plugin.currentSession.difficulty = parseInt(this.difficultySlider.value);
        }
        this.plugin.currentSession.pomodorosCompleted++;
        const sessionData = this.plugin.currentSession.end();
        await this.plugin.saveSessionToFile(sessionData);
        const isLongBreak = this.pomodoroCount % this.plugin.settings.longBreakInterval === 0;
        const breakTime = isLongBreak ? this.plugin.settings.longBreakTime : this.plugin.settings.shortBreakTime;
        if (document.hidden) {
          new Notification("Pomodoro Timer", {
            body: `Pomodoro completed! Time for a ${isLongBreak ? "long" : "short"} break.`
          });
        }
        new import_obsidian.Notice(`Pomodoro completed! Take a ${isLongBreak ? "long" : "short"} break.`);
        this.timeLeft = breakTime * 60;
        this.isBreak = true;
        this.notesArea.value = "";
        this.distractionInput.value = "";
        if (this.difficultySlider) {
          this.difficultySlider.value = "1";
        }
        this.plugin.startNewSession("~Break~");
        this.categorySelect.value = "~Break~";
        if (this.plugin.settings.autoStartBreaks) {
          this.startTimer();
        }
      }
    } else {
      if (document.hidden) {
        new Notification("Pomodoro Timer", {
          body: "Break completed! Ready to start working?"
        });
      }
      new import_obsidian.Notice("Break completed!");
      this.timeLeft = this.plugin.settings.pomodoroTime * 60;
      this.isBreak = false;
      if (this.plugin.currentSession) {
        this.plugin.currentSession.notes = this.notesArea.value;
        const sessionData = this.plugin.currentSession.end();
        await this.plugin.saveSessionToFile(sessionData);
        this.notesArea.value = "";
        this.distractionInput.value = "";
        if (this.difficultySlider) {
          this.difficultySlider.value = "1";
        }
      }
      if (this.plugin.settings.autoStartPomodoros) {
        const category = this.plugin.settings.categories.find((c) => c !== "~Break~") || "Study";
        this.plugin.startNewSession(category);
        this.categorySelect.value = category;
        this.startTimer();
      }
    }
    this.updateTimerDisplay();
    await this.updateDailyTime();
  }
  onLayoutReady() {
    if (this.isRunning && this.interval) {
      const now = Date.now();
      if (this.isStopwatch) {
        this.stopwatchElapsed = now - this.stopwatchStartTime;
      } else {
        const elapsed = Math.floor((now - this.lastUpdate) / 1e3);
        if (elapsed > 0) {
          this.timeLeft = Math.max(0, this.timeLeft - elapsed);
          this.lastUpdate = now;
          if (this.timeLeft <= 0) {
            this.completeTimer();
          }
        }
      }
      this.updateTimerDisplay();
      this.updateDailyTime();
    }
  }
  addReflection() {
    const modal = new import_obsidian.Modal(this.app);
    modal.titleEl.setText("Add Reflection");
    const contentEl = modal.contentEl;
    const statsEl = contentEl.createEl("div", { cls: "reflection-stats" });
    if (this.plugin.currentSession) {
      const session = this.plugin.currentSession;
      statsEl.innerHTML = `
                <div class="stats-overview">
                    <p>\u{1F4CA} Current Session Stats:</p>
                    <ul>
                        <li>\u23F1\uFE0F Duration: ${session.getDuration()} minutes</li>
                        <li>\u{1F345} Pomodoros: ${session.pomodorosCompleted}</li>
                        <li>\u26A0\uFE0F Distractions: ${session.distractions.length}</li>
                        <li>\u{1F4DD} Modified Files: ${session.modifiedFiles.size}</li>
                        <li>\u2705 Completed Tasks: ${session.completedTasks.length}</li>
                    </ul>
                </div>
            `;
    }
    contentEl.createEl("p", { text: "\u{1F4AD} What are your thoughts on this study session so far?" });
    const reflectionInput = contentEl.createEl("textarea", {
      attr: {
        rows: "6",
        placeholder: "Enter your reflection here..."
      }
    });
    const buttonDiv = contentEl.createEl("div", { cls: "button-section" });
    const submitButton = buttonDiv.createEl("button", {
      text: "Add Reflection",
      cls: "mod-cta"
    });
    submitButton.onclick = () => {
      if (reflectionInput.value.trim()) {
        if (this.plugin.currentSession) {
          this.plugin.currentSession.addReflection(reflectionInput.value);
          const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString();
          const currentNotes = this.notesArea.value;
          const reflection = `

##### Reflection (${timestamp})
${reflectionInput.value}`;
          this.notesArea.value = currentNotes + reflection;
        }
        modal.close();
        new import_obsidian.Notice("Reflection added");
      }
    };
    modal.open();
  }
  reportDistraction() {
    if (this.distractionInput.value.trim()) {
      if (this.plugin.currentSession) {
        this.plugin.currentSession.addDistraction(this.distractionInput.value);
        this.distractionInput.value = "";
        new import_obsidian.Notice("Distraction recorded");
      }
    }
  }
};
var StudyFlowSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h3", { text: "Timer Settings" });
    new import_obsidian.Setting(containerEl).setName("Pomodoro Duration").setDesc("Duration in minutes").addText((text) => text.setValue(String(this.plugin.settings.pomodoroTime)).onChange(async (value) => {
      this.plugin.settings.pomodoroTime = parseInt(value) || 25;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Short Break Duration").setDesc("Duration in minutes").addText((text) => text.setValue(String(this.plugin.settings.shortBreakTime)).onChange(async (value) => {
      this.plugin.settings.shortBreakTime = parseInt(value) || 5;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Long Break Duration").setDesc("Duration in minutes").addText((text) => text.setValue(String(this.plugin.settings.longBreakTime)).onChange(async (value) => {
      this.plugin.settings.longBreakTime = parseInt(value) || 15;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Long Break Interval").setDesc("Number of pomodoros before long break").addText((text) => text.setValue(String(this.plugin.settings.longBreakInterval)).onChange(async (value) => {
      this.plugin.settings.longBreakInterval = parseInt(value) || 4;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Tags" });
    const tagInput = new import_obsidian.Setting(containerEl).setName("Add new tag").addText((text) => text.setPlaceholder("Add new tag")).addButton((button) => button.setButtonText("Add Tag").onClick(() => {
      var _a;
      let value = tagInput.components[0];
      value = (_a = value == null ? void 0 : value.inputEl) == null ? void 0 : _a.value;
      if (value) {
        if (!value.startsWith("#")) {
          value = "#" + value;
        }
        this.plugin.settings.tags.push(value);
        this.plugin.saveSettings();
        tagInput.components[0].inputEl.value = "";
        this.display();
      }
    }));
    this.plugin.settings.tags.forEach((tag, index) => {
      new import_obsidian.Setting(containerEl).setName(tag).addButton((button) => button.setIcon("trash").onClick(async () => {
        this.plugin.settings.tags.splice(index, 1);
        await this.plugin.saveSettings();
        this.display();
      }));
    });
    containerEl.createEl("h3", { text: "Categories" });
    const categoryInput = new import_obsidian.Setting(containerEl).setName("Add new category").addText((text) => text.setPlaceholder("Add new category")).addButton((button) => button.setButtonText("Add Category").onClick(() => {
      var _a;
      let value = categoryInput.components[0];
      value = (_a = value == null ? void 0 : value.inputEl) == null ? void 0 : _a.value;
      if (value && value !== "~Break~") {
        this.plugin.settings.categories.push(value);
        this.plugin.saveSettings();
        categoryInput.components[0].inputEl.value = "";
        this.display();
      }
    }));
    this.plugin.settings.categories.forEach((category, index) => {
      const setting = new import_obsidian.Setting(containerEl).setName(category);
      if (category !== "Break") {
        setting.addButton((button) => button.setIcon("trash").onClick(async () => {
          this.plugin.settings.categories.splice(index, 1);
          await this.plugin.saveSettings();
          this.display();
        }));
      }
    });
    containerEl.createEl("h3", { text: "Other Settings" });
    new import_obsidian.Setting(containerEl).setName("Notes Folder").setDesc("Folder for session notes").addText((text) => text.setValue(this.plugin.settings.notesFolder).onChange(async (value) => {
      this.plugin.settings.notesFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Focus Path").setDesc("Path for tracking modified files").addText((text) => text.setValue(this.plugin.settings.focusPath).onChange(async (value) => {
      this.plugin.settings.focusPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto-start breaks").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoStartBreaks).onChange(async (value) => {
      this.plugin.settings.autoStartBreaks = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto-start pomodoros").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoStartPomodoros).onChange(async (value) => {
      this.plugin.settings.autoStartPomodoros = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show difficulty slider").addToggle((toggle) => toggle.setValue(this.plugin.settings.showDifficulty).onChange(async (value) => {
      this.plugin.settings.showDifficulty = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Track modified files").addToggle((toggle) => toggle.setValue(this.plugin.settings.trackModifiedFiles).onChange(async (value) => {
      this.plugin.settings.trackModifiedFiles = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Track opened files").setDesc("Track files that are opened during a study session").addToggle((toggle) => toggle.setValue(this.plugin.settings.trackOpenedFiles).onChange(async (value) => {
      this.plugin.settings.trackOpenedFiles = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Track word count").setDesc("Track the number of words written during study sessions").addToggle((toggle) => toggle.setValue(this.plugin.settings.trackWordCount).onChange(async (value) => {
      this.plugin.settings.trackWordCount = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Summary Settings" });
    new import_obsidian.Setting(containerEl).setName("Create daily summary").setDesc("Create a daily summary note at the end of the day").addToggle((toggle) => toggle.setValue(this.plugin.settings.createDailySummary).onChange(async (value) => {
      this.plugin.settings.createDailySummary = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable weekly summary").setDesc("Automatically create a weekly summary note").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableWeeklySummary).onChange(async (value) => {
      this.plugin.settings.enableWeeklySummary = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Weekly summary day").setDesc("Day of the week to create the weekly summary").addDropdown((dropdown) => dropdown.addOption("0", "Sunday").addOption("1", "Monday").addOption("2", "Tuesday").addOption("3", "Wednesday").addOption("4", "Thursday").addOption("5", "Friday").addOption("6", "Saturday").setValue(String(this.plugin.settings.weeklySummaryDay)).onChange(async (value) => {
      this.plugin.settings.weeklySummaryDay = parseInt(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Preserve temporary session files").setDesc("Keep temporary session data files even after creating summaries (for historical data)").addToggle((toggle) => toggle.setValue(this.plugin.settings.preserveTempFiles).onChange(async (value) => {
      this.plugin.settings.preserveTempFiles = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Keep long-term session data").setDesc("Store session data long-term instead of deleting after summaries").addToggle((toggle) => toggle.setValue(this.plugin.settings.keepLongTermData).onChange(async (value) => {
      this.plugin.settings.keepLongTermData = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Track tagged notes").setDesc("Track notes with specific tags in summaries").addToggle((toggle) => toggle.setValue(this.plugin.settings.trackTaggedNotes).onChange(async (value) => {
      this.plugin.settings.trackTaggedNotes = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Reset timer on new session").setDesc("Reset the timer when starting a new session").addToggle((toggle) => toggle.setValue(this.plugin.settings.resetTimerOnNewSession).onChange(async (value) => {
      this.plugin.settings.resetTimerOnNewSession = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto-track sessions on startup").setDesc("Automatically start tracking when Obsidian opens").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoTrackSessionOnStartup).onChange(async (value) => {
      this.plugin.settings.autoTrackSessionOnStartup = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto-create daily summary").setDesc("Automatically create daily summary at midnight").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoDailySummary).onChange(async (value) => {
      this.plugin.settings.autoDailySummary = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto-create weekly summary").setDesc("Automatically create weekly summary on the specified day").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoWeeklySummary).onChange(async (value) => {
      this.plugin.settings.autoWeeklySummary = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto-set category by folder").setDesc("Automatically set category based on folder").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSetCategoryByFolder).onChange(async (value) => {
      this.plugin.settings.autoSetCategoryByFolder = value;
      await this.plugin.saveSettings();
    }));
    if (this.plugin.settings.autoSetCategoryByFolder) {
      containerEl.createEl("h4", { text: "Folder-Category Mappings" });
      for (const folderPath in this.plugin.settings.folderCategoryMappings) {
        const category = this.plugin.settings.folderCategoryMappings[folderPath];
        const mappingSetting = new import_obsidian.Setting(containerEl).setName(folderPath).setDesc(`Category: ${category}`);
        mappingSetting.addButton((button) => button.setIcon("trash").setTooltip("Delete mapping").onClick(async () => {
          delete this.plugin.settings.folderCategoryMappings[folderPath];
          await this.plugin.saveSettings();
          this.display();
        }));
      }
      const newMappingSetting = new import_obsidian.Setting(containerEl).setName("Add Folder-Category Mapping").setDesc("Map a folder path to a specific category");
      let folderPathInput;
      let categoryDropdown;
      newMappingSetting.addText((text) => {
        folderPathInput = text.inputEl;
        return text.setPlaceholder("Folder path (e.g., folder/subfolder)").setValue("");
      });
      newMappingSetting.addDropdown((dropdown) => {
        categoryDropdown = dropdown.selectEl;
        this.plugin.settings.categories.forEach((cat) => {
          if (cat !== "~Break~") {
            dropdown.addOption(cat, cat);
          }
        });
        return dropdown.setValue(this.plugin.settings.categories[0] || "Study");
      });
      newMappingSetting.addButton((button) => button.setIcon("plus").setTooltip("Add mapping").onClick(async () => {
        const folderPath = folderPathInput.value.trim();
        const category = categoryDropdown.value;
        if (folderPath && category) {
          this.plugin.settings.folderCategoryMappings[folderPath] = category;
          await this.plugin.saveSettings();
          folderPathInput.value = "";
          this.display();
        }
      }));
    }
    containerEl.createEl("h4", { text: "Tags to Track" });
    const tagsToTrackSetting = new import_obsidian.Setting(containerEl).setName("Tags to Track").setDesc("Track notes with these tags in weekly summaries (comma-separated, include # if needed)");
    tagsToTrackSetting.addText((text) => text.setPlaceholder("#tag1, #tag2").setValue(this.plugin.settings.tagsToTrack.join(", ")).onChange(async (value) => {
      this.plugin.settings.tagsToTrack = value.split(",").map((tag) => tag.trim()).filter((tag) => tag.length > 0);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Track created notes").setDesc("Track newly created notes during sessions").addToggle((toggle) => toggle.setValue(this.plugin.settings.trackCreatedNotes).onChange(async (value) => {
      this.plugin.settings.trackCreatedNotes = value;
      await this.plugin.saveSettings();
    }));
  }
};
var StudyAnalyticsPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.currentSession = null;
  }
  async onload() {
    await this.loadSettings();
    if (typeof Notification !== "undefined" && Notification.permission !== "granted") {
      try {
        await Notification.requestPermission();
      } catch (e) {
        console.log("Notification permission denied");
      }
    }
    this.app.workspace.onLayoutReady(() => {
      this.checkWeeklySummary();
      this.startAutoTracking();
    });
    this.registerView(
      VIEW_TYPE_STUDY_FLOW,
      (leaf) => new StudyFlowView(leaf, this)
    );
    this.addCommand({
      id: "show-study-flow",
      name: "Show Study Flow",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "create-daily-summary",
      name: "Create Daily Summary",
      callback: async () => {
        await this.createDailySummary();
      }
    });
    this.addCommand({
      id: "create-weekly-summary",
      name: "Create Weekly Summary",
      callback: async () => {
        await this.createWeeklySummary();
      }
    });
    this.app.workspace.onLayoutReady(() => {
      this.activateView();
    });
    document.addEventListener("visibilitychange", () => {
      const view = this.getStudyFlowView();
      if (view && !document.hidden) {
        view.onLayoutReady();
      }
    });
    this.addCommand({
      id: "add-line-note",
      name: "Add Line Note",
      editorCallback: (editor, view) => {
        if (!this.currentSession) {
          new import_obsidian.Notice("No active study session!");
          return;
        }
        const line = editor.getLine(editor.getCursor().line);
        const lineNumber = editor.getCursor().line + 1;
        const modal = new import_obsidian.Modal(this.app);
        modal.titleEl.setText("Add Line Note");
        const contentEl = modal.contentEl;
        const lineDiv = contentEl.createEl("div", { cls: "line-note-section" });
        lineDiv.createEl("strong", { text: "Selected Line:" });
        lineDiv.createEl("pre", { text: line });
        const tagDiv = contentEl.createEl("div", { cls: "tag-section" });
        tagDiv.createEl("strong", { text: "Select Tag:" });
        const tagSelect = tagDiv.createEl("select");
        this.settings.tags.forEach((tag) => {
          tagSelect.createEl("option", { value: tag, text: tag });
        });
        const noteDiv = contentEl.createEl("div", { cls: "note-section" });
        noteDiv.createEl("strong", { text: "Your Note:" });
        const noteInput = contentEl.createEl("textarea", {
          attr: {
            rows: "4",
            placeholder: "Add your note here..."
          }
        });
        const buttonDiv = contentEl.createEl("div", { cls: "button-section" });
        const submitButton = buttonDiv.createEl("button", {
          text: "Save Note",
          cls: "mod-cta"
        });
        submitButton.onclick = () => {
          if (tagSelect.value) {
            this.currentSession.addLineNote(
              line,
              view.file.path,
              tagSelect.value,
              noteInput.value,
              lineNumber
            );
            new import_obsidian.Notice("Line note added");
            modal.close();
          } else {
            new import_obsidian.Notice("Please select a tag");
          }
        };
        modal.open();
      }
    });
    this.addSettingTab(new StudyFlowSettingTab(this.app, this));
    this.statusBarItem = this.addStatusBarItem();
    this.updateStatusBar("25:00");
    this.registerEvent(
      this.app.vault.on("modify", async (file) => {
        if (this.currentSession && file instanceof import_obsidian.TFile) {
          const shouldTrack = !this.settings.focusPath || file.path.startsWith(this.settings.focusPath);
          if (shouldTrack) {
            if (this.settings.trackModifiedFiles) {
              this.currentSession.trackModifiedFile(file.path);
            }
            const content = await this.app.vault.cachedRead(file);
            const newTasks = this.findNewlyCompletedTasks(content, file.path);
            newTasks.forEach((task) => {
              this.currentSession.addCompletedTask(task);
            });
            if (this.settings.trackWordCount) {
              const wordCount = this.countWords(content);
              this.currentSession.updateWordCount(file.path, wordCount);
            }
            if (this.settings.autoSetCategoryByFolder) {
              this.updateCategoryByFolder(file.path);
            }
          }
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        if (this.currentSession && file && this.settings.trackOpenedFiles) {
          const shouldTrack = !this.settings.focusPath || file.path.startsWith(this.settings.focusPath);
          if (shouldTrack) {
            this.currentSession.trackOpenedFile(file.path);
            if (this.settings.autoSetCategoryByFolder) {
              this.updateCategoryByFolder(file.path);
            }
          }
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (this.currentSession && file instanceof import_obsidian.TFile && this.settings.trackCreatedNotes) {
          const shouldTrack = !this.settings.focusPath || file.path.startsWith(this.settings.focusPath);
          if (shouldTrack) {
            this.currentSession.trackModifiedFile(file.path);
            this.currentSession.trackOpenedFile(file.path);
            this.currentSession.trackCreatedFile(file.path);
            this.currentSession.initialLinkCounts.set(file.path, 0);
          }
        }
      })
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        if (this.currentSession && file instanceof import_obsidian.TFile) {
          const shouldTrack = !this.settings.focusPath || file.path.startsWith(this.settings.focusPath);
          if (shouldTrack) {
            const cache = this.app.metadataCache.getFileCache(file);
            if (cache) {
              const linkCount = (cache.links || []).length + (cache.embeds || []).length;
              this.currentSession.updateLinkCount(file.path, linkCount);
            }
          }
        }
      })
    );
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    if (this.app.workspace.getLeavesOfType(VIEW_TYPE_STUDY_FLOW).length === 0) {
      await this.app.workspace.getRightLeaf(false).setViewState({
        type: VIEW_TYPE_STUDY_FLOW,
        active: true
      });
    }
    this.app.workspace.revealLeaf(
      this.app.workspace.getLeavesOfType(VIEW_TYPE_STUDY_FLOW)[0]
    );
  }
  getStudyFlowView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_STUDY_FLOW);
    if (leaves.length > 0) {
      return leaves[0].view;
    }
    return null;
  }
  startNewSession(category) {
    this.currentSession = new StudySession(category);
  }
  async endCurrentSession() {
    if (this.currentSession) {
      const view = this.getStudyFlowView();
      if (view) {
        this.currentSession.notes = view.notesArea.value;
        if (this.settings.showDifficulty) {
          this.currentSession.difficulty = parseInt(view.difficultySlider.value);
        }
      }
      const sessionData = this.currentSession.end();
      await this.saveSessionToFile(sessionData);
      this.currentSession = null;
      if (view) {
        view.resetSession();
      }
      new import_obsidian.Notice("Session ended and saved");
    }
  }
  async saveSessionToFile(sessionData) {
    const tempFileName = `temp_${(/* @__PURE__ */ new Date()).getTime()}.json`;
    const tempFolderPath = `${this.settings.notesFolder}/temp`;
    if (!await this.app.vault.adapter.exists(tempFolderPath)) {
      await this.app.vault.createFolder(tempFolderPath);
    }
    await this.app.vault.adapter.write(
      `${tempFolderPath}/${tempFileName}`,
      JSON.stringify(sessionData, null, 2)
    );
  }
  async createDailySummary(date) {
    var _a, _b, _c;
    const summaryDate = date || (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    const tempFolderPath = `${this.settings.notesFolder}/temp`;
    const summaryFileName = `${summaryDate}_daily_summary.md`;
    const summaryFilePath = `${this.settings.notesFolder}/${summaryFileName}`;
    let studySessions = [];
    let breakSessions = [];
    try {
      if (!await this.app.vault.adapter.exists(tempFolderPath)) {
        new import_obsidian.Notice("No study sessions found for the specified date");
        return null;
      }
      const tempFiles = await this.app.vault.adapter.list(tempFolderPath);
      let totalStudyTime = 0;
      let totalBreakTime = 0;
      let totalPomodoros = 0;
      let totalDistractions = 0;
      const modifiedFiles = /* @__PURE__ */ new Set();
      const openedFiles = /* @__PURE__ */ new Set();
      const createdFiles = /* @__PURE__ */ new Set();
      const createdLinks = /* @__PURE__ */ new Set();
      let totalTasks = 0;
      let totalWordCount = 0;
      let totalCreatedFiles = 0;
      let totalCreatedLinks = 0;
      const difficulties = [];
      for (const file of tempFiles.files) {
        const content = await this.app.vault.adapter.read(file);
        const sessionData = JSON.parse(content);
        if (sessionData.date === summaryDate) {
          if (sessionData.isBreak) {
            breakSessions.push(sessionData);
            totalBreakTime += sessionData.duration;
          } else {
            studySessions.push(sessionData);
            totalStudyTime += sessionData.duration;
            totalPomodoros += sessionData.pomodoros;
            totalDistractions += sessionData.distractions.length;
            sessionData.modifiedFiles.forEach((f) => modifiedFiles.add(f));
            (_a = sessionData.openedFiles) == null ? void 0 : _a.forEach((f) => openedFiles.add(f));
            (_b = sessionData.createdFiles) == null ? void 0 : _b.forEach((f) => createdFiles.add(f));
            (_c = sessionData.createdLinks) == null ? void 0 : _c.forEach((l) => createdLinks.add(l));
            totalTasks += sessionData.completedTasks.length;
            difficulties.push(sessionData.difficulty);
            totalWordCount += sessionData.wordCount || 0;
          }
        }
      }
      totalCreatedFiles = createdFiles.size;
      totalCreatedLinks = createdLinks.size;
      if (studySessions.length === 0) {
        new import_obsidian.Notice(`No study sessions found for ${summaryDate}`);
        return null;
      }
      const avgDifficulty = difficulties.length > 0 ? (difficulties.reduce((a, b) => a + b) / difficulties.length).toFixed(1) : "0";
      const studyHours = Math.floor(totalStudyTime / 60);
      const studyMinutes = totalStudyTime % 60;
      const breakHours = Math.floor(totalBreakTime / 60);
      const breakMinutes = totalBreakTime % 60;
      const totalTimeHours = Math.floor((totalStudyTime + totalBreakTime) / 60);
      const totalTimeMinutes = (totalStudyTime + totalBreakTime) % 60;
      let summaryContent = `# Daily Study Summary - ${summaryDate}

`;
      summaryContent += `Study time:: ${studyHours}h ${studyMinutes}m
`;
      summaryContent += `Break time:: ${breakHours}h ${breakMinutes}m
`;
      summaryContent += `Total time:: ${totalTimeHours}h ${totalTimeMinutes}m
`;
      summaryContent += `Pomodoros:: ${totalPomodoros}
`;
      summaryContent += `Modified files:: ${modifiedFiles.size}
`;
      summaryContent += `Created files:: ${totalCreatedFiles}
`;
      summaryContent += `Created links:: ${totalCreatedLinks}
`;
      summaryContent += `Words written:: ${totalWordCount}

`;
      summaryContent += `## \u{1F4CA} Daily Statistics
`;
      summaryContent += `- \u23F1\uFE0F Study Time: ${studyHours}h ${studyMinutes}m
`;
      summaryContent += `- \u23F8\uFE0F Break Time: ${breakHours}h ${breakMinutes}m
`;
      summaryContent += `- \u{1F559} Total Time: ${totalTimeHours}h ${totalTimeMinutes}m
`;
      summaryContent += `- \u{1F345} Total Pomodoros: ${totalPomodoros}
`;
      summaryContent += `- \u26A0\uFE0F Total Distractions: ${totalDistractions}
`;
      summaryContent += `- \u{1F4DD} Modified Files: ${modifiedFiles.size}
`;
      summaryContent += `- \u{1F4D6} Opened Files: ${openedFiles.size}
`;
      summaryContent += `- \u{1F4C4} Created Files: ${totalCreatedFiles}
`;
      summaryContent += `- \u{1F517} Created Links: ${totalCreatedLinks}
`;
      summaryContent += `- \u2705 Completed Tasks: ${totalTasks}
`;
      summaryContent += `- \u{1F4CF} Words Written: ${totalWordCount}
`;
      summaryContent += `- \u{1F4C8} Average Difficulty: ${avgDifficulty}/5

`;
      if (modifiedFiles.size > 0) {
        summaryContent += `## \u{1F4DD} Modified Files Overview
`;
        modifiedFiles.forEach((file) => {
          summaryContent += `- [[${file}|${file.split("/").pop()}]]
`;
        });
        summaryContent += "\n";
      }
      if (openedFiles.size > 0) {
        summaryContent += `## \u{1F4D6} Opened Files Overview
`;
        openedFiles.forEach((file) => {
          summaryContent += `- [[${file}|${file.split("/").pop()}]]
`;
        });
        summaryContent += "\n";
      }
      if (createdFiles.size > 0) {
        summaryContent += `## \u{1F4C4} Created Files Overview
`;
        createdFiles.forEach((file) => {
          summaryContent += `- [[${file}|${file.split("/").pop()}]]
`;
        });
        summaryContent += "\n";
      }
      if (createdLinks.size > 0) {
        summaryContent += `## \u{1F517} Created Links Overview
`;
        createdLinks.forEach((link) => {
          if (typeof link === "string") {
            const parts = link.split(":");
            if (parts.length === 2) {
              const [filePath, index] = parts;
              summaryContent += `- Link ${index} in [[${filePath}|${filePath.split("/").pop()}]]
`;
            } else {
              summaryContent += `- ${link}
`;
            }
          } else {
            summaryContent += `- Unknown link format
`;
          }
        });
        summaryContent += "\n";
      }
      studySessions.forEach((session, index) => {
        summaryContent += `## Study Session ${index + 1}: ${session.category}
`;
        summaryContent += `- Start Time: ${new Date(session.startTime).toLocaleTimeString()}
`;
        summaryContent += `- Duration: ${Math.floor(session.duration / 60)}h ${session.duration % 60}m
`;
        summaryContent += `- Pomodoros: ${session.pomodoros}
`;
        if (session.wordCount) {
          summaryContent += `- Words Written: ${session.wordCount}
`;
        }
        if (session.createdFiles && session.createdFiles.length > 0) {
          summaryContent += `- Created Files: ${session.createdFiles.length}
`;
        }
        if (session.createdLinks && session.createdLinks.length > 0) {
          summaryContent += `- Created Links: ${session.createdLinks.length}
`;
        }
        summaryContent += `- Difficulty: ${session.difficulty}/5

`;
        if (session.notes) {
          summaryContent += `### Notes
${session.notes}

`;
        }
        if (session.reflections.length > 0) {
          session.reflections.forEach((r) => {
            summaryContent += `##### Reflection - ${new Date(r.time).toLocaleTimeString()}
${r.text}

`;
          });
        }
        if (session.distractions.length > 0) {
          summaryContent += `### Distractions
`;
          session.distractions.forEach((d) => {
            summaryContent += `- ${new Date(d.time).toLocaleTimeString()}: ${d.note}
`;
          });
          summaryContent += "\n";
        }
        if (session.lineNotes.length > 0) {
          summaryContent += `### Line Notes
`;
          session.lineNotes.forEach((n) => {
            summaryContent += `#### [[${n.file}#${n.lineNumber}|${n.file.split("/").pop()}:${n.lineNumber}]]
`;
            summaryContent += `${n.tag}
\`\`\`
${n.line}
\`\`\`
${n.note}

`;
          });
        }
      });
      if (this.settings.createDailySummary || !date) {
        if (!await this.app.vault.adapter.exists(this.settings.notesFolder)) {
          await this.app.vault.createFolder(this.settings.notesFolder);
        }
        await this.app.vault.create(summaryFilePath, summaryContent);
        if (!date && !this.settings.preserveTempFiles && !this.settings.keepLongTermData) {
          for (const file of tempFiles.files) {
            const content = await this.app.vault.adapter.read(file);
            const sessionData = JSON.parse(content);
            if (sessionData.date === summaryDate) {
              await this.app.vault.adapter.remove(file);
            }
          }
        }
        new import_obsidian.Notice("Daily summary created successfully!");
      }
      return {
        studySessions,
        breakSessions,
        totalStudyTime,
        totalBreakTime,
        totalPomodoros,
        totalDistractions,
        totalTasks,
        totalWordCount,
        avgDifficulty,
        modifiedFiles: Array.from(modifiedFiles),
        openedFiles: Array.from(openedFiles),
        createdFiles: Array.from(createdFiles),
        createdLinks: Array.from(createdLinks)
      };
    } catch (error) {
      console.error("Error creating daily summary:", error);
      new import_obsidian.Notice("Error creating daily summary");
      return null;
    }
  }
  async createWeeklySummary() {
    try {
      const now = /* @__PURE__ */ new Date();
      const currentDay = now.getDay();
      const diff = now.getDate() - currentDay + (currentDay === 0 ? -6 : 1);
      const monday = new Date(now.setDate(diff));
      monday.setHours(0, 0, 0, 0);
      const sunday = new Date(monday);
      sunday.setDate(sunday.getDate() + 6);
      const weekDates = [];
      const currentDate = new Date(monday);
      while (currentDate <= sunday) {
        weekDates.push(currentDate.toISOString().split("T")[0]);
        currentDate.setDate(currentDate.getDate() + 1);
      }
      let weeklyStudyTime = 0;
      let weeklyBreakTime = 0;
      let weeklyPomodoros = 0;
      let weeklyDistractions = 0;
      let weeklyTasks = 0;
      let weeklyWordCount = 0;
      let totalCreatedFiles = 0;
      let totalCreatedLinks = 0;
      let totalCreatedNotes = 0;
      let totalModifiedNotes = 0;
      const allDifficulties = [];
      const modifiedFiles = /* @__PURE__ */ new Set();
      const openedFiles = /* @__PURE__ */ new Set();
      const createdFiles = /* @__PURE__ */ new Set();
      const createdLinks = /* @__PURE__ */ new Set();
      const taggedNotes = /* @__PURE__ */ new Map();
      if (this.settings.trackTaggedNotes && this.settings.tagsToTrack) {
        for (const tag of this.settings.tagsToTrack) {
          taggedNotes.set(tag, /* @__PURE__ */ new Set());
        }
      }
      const dayReports = [];
      for (const date of weekDates) {
        const dayData = await this.createDailySummary(date);
        {
          let dayCreatedNotes = 0;
          let dayModifiedNotes = 0;
          if (!dayData) {
            dayReports.push({
              date,
              studyTime: 0,
              breakTime: 0,
              pomodoros: 0,
              wordCount: 0,
              createdNotes: 0,
              modifiedNotes: 0
            });
          } else {
            weeklyStudyTime += dayData.totalStudyTime;
            weeklyBreakTime += dayData.totalBreakTime;
            weeklyPomodoros += dayData.totalPomodoros;
            weeklyDistractions += dayData.totalDistractions;
            weeklyTasks += dayData.totalTasks;
            weeklyWordCount += dayData.totalWordCount;
            dayData.modifiedFiles.forEach((file) => {
              modifiedFiles.add(file);
              if (file.endsWith(".md")) {
                dayModifiedNotes++;
                totalModifiedNotes++;
              }
            });
            dayData.openedFiles.forEach((file) => openedFiles.add(file));
            if (Array.isArray(dayData.createdFiles)) {
              dayData.createdFiles.forEach((file) => {
                createdFiles.add(file);
                if (file.endsWith(".md")) {
                  dayCreatedNotes++;
                  totalCreatedNotes++;
                }
              });
              totalCreatedFiles = createdFiles.size;
            }
            if (Array.isArray(dayData.createdLinks)) {
              dayData.createdLinks.forEach((link) => createdLinks.add(link));
              totalCreatedLinks = createdLinks.size;
            }
            if (this.settings.trackTaggedNotes && this.settings.tagsToTrack && this.settings.tagsToTrack.length > 0) {
              const possibleTaggedFiles = dayData.modifiedFiles.filter((file) => file.endsWith(".md"));
              for (const file of possibleTaggedFiles) {
                const tfile = this.app.vault.getAbstractFileByPath(file);
                if (tfile instanceof import_obsidian.TFile) {
                  const cache = this.app.metadataCache.getFileCache(tfile);
                  if (cache && cache.tags) {
                    const fileTags = cache.tags.map((t) => t.tag);
                    for (const trackedTag of this.settings.tagsToTrack) {
                      if (fileTags.includes(trackedTag)) {
                        const tagSet = taggedNotes.get(trackedTag);
                        if (tagSet) {
                          tagSet.add(file);
                        }
                      }
                    }
                  }
                }
              }
            }
            if (dayData.avgDifficulty && parseFloat(dayData.avgDifficulty) > 0) {
              allDifficulties.push(parseFloat(dayData.avgDifficulty));
            }
            dayReports.push({
              date,
              studyTime: dayData.totalStudyTime,
              breakTime: dayData.totalBreakTime,
              pomodoros: dayData.totalPomodoros,
              wordCount: dayData.totalWordCount,
              createdNotes: dayCreatedNotes,
              modifiedNotes: dayModifiedNotes
            });
          }
        }
      }
      if (dayReports.length === 0) {
        new import_obsidian.Notice("No study data found for this week");
        return;
      }
      const avgDifficulty = allDifficulties.length > 0 ? (allDifficulties.reduce((a, b) => a + b) / allDifficulties.length).toFixed(1) : "0";
      const studyHours = Math.floor(weeklyStudyTime / 60);
      const studyMinutes = weeklyStudyTime % 60;
      const breakHours = Math.floor(weeklyBreakTime / 60);
      const breakMinutes = weeklyBreakTime % 60;
      const totalTimeHours = Math.floor((weeklyStudyTime + weeklyBreakTime) / 60);
      const totalTimeMinutes = (weeklyStudyTime + weeklyBreakTime) % 60;
      const mondayStr = monday.toISOString().split("T")[0];
      const sundayStr = sunday.toISOString().split("T")[0];
      const weekRange = `${mondayStr} to ${sundayStr}`;
      let summaryContent = `# Weekly Study Summary - ${weekRange}

`;
      summaryContent += `Study time:: ${studyHours}h ${studyMinutes}m
`;
      summaryContent += `Break time:: ${breakHours}h ${breakMinutes}m
`;
      summaryContent += `Total time:: ${totalTimeHours}h ${totalTimeMinutes}m
`;
      summaryContent += `Pomodoros:: ${weeklyPomodoros}
`;
      summaryContent += `Modified files:: ${modifiedFiles.size}
`;
      summaryContent += `Words written:: ${weeklyWordCount}

`;
      summaryContent += `## \u{1F4CA} Weekly Statistics
`;
      summaryContent += `- \u23F1\uFE0F Study Time: ${studyHours}h ${studyMinutes}m
`;
      summaryContent += `- \u23F8\uFE0F Break Time: ${breakHours}h ${breakMinutes}m
`;
      summaryContent += `- \u{1F559} Total Time: ${totalTimeHours}h ${totalTimeMinutes}m
`;
      summaryContent += `- \u{1F345} Total Pomodoros: ${weeklyPomodoros}
`;
      summaryContent += `- \u26A0\uFE0F Total Distractions: ${weeklyDistractions}
`;
      summaryContent += `- \u{1F4DD} Modified Files: ${modifiedFiles.size}
`;
      summaryContent += `- \u{1F4D6} Opened Files: ${openedFiles.size}
`;
      summaryContent += `- \u{1F4C4} Created Files: ${totalCreatedFiles}
`;
      summaryContent += `- \u{1F4D4} Created Notes: ${totalCreatedNotes}
`;
      summaryContent += `- \u{1F4DD} Modified Notes: ${totalModifiedNotes}
`;
      summaryContent += `- \u{1F517} Created Links: ${totalCreatedLinks}
`;
      summaryContent += `- \u2705 Completed Tasks: ${weeklyTasks}
`;
      summaryContent += `- \u{1F4CF} Words Written: ${weeklyWordCount}
`;
      summaryContent += `- \u{1F4C8} Average Difficulty: ${avgDifficulty}/5

`;
      summaryContent += `## \u{1F4C6} Daily Breakdown
`;
      summaryContent += `| Date | Study Time | Break Time | Pomodoros | Words Written | Created Notes | Modified Notes |
`;
      summaryContent += `| ---- | ---------- | ---------- | --------- | ------------- | ------------ | -------------- |
`;
      dayReports.forEach((day) => {
        const dayStudyHours = Math.floor(day.studyTime / 60);
        const dayStudyMinutes = day.studyTime % 60;
        const dayBreakHours = Math.floor(day.breakTime / 60);
        const dayBreakMinutes = day.breakTime % 60;
        summaryContent += `| ${day.date} | ${dayStudyHours}h ${dayStudyMinutes}m | ${dayBreakHours}h ${dayBreakMinutes}m | ${day.pomodoros} | ${day.wordCount} | ${day.createdNotes} | ${day.modifiedNotes} |
`;
      });
      summaryContent += "\n";
      if (modifiedFiles.size > 0) {
        summaryContent += `## \u{1F4DD} Most Modified Files
`;
        const fileArray = Array.from(modifiedFiles);
        const limitedFiles = fileArray.slice(0, 10);
        limitedFiles.forEach((file) => {
          summaryContent += `- [[${file}|${file.split("/").pop()}]]
`;
        });
        if (fileArray.length > 10) {
          summaryContent += `- ... and ${fileArray.length - 10} more files
`;
        }
        summaryContent += "\n";
      }
      if (totalCreatedFiles > 0) {
        summaryContent += `## \u{1F4C4} Created Files
`;
        const createdFilesArray = Array.from(createdFiles);
        const limitedCreatedFiles = createdFilesArray.slice(0, 10);
        limitedCreatedFiles.forEach((file) => {
          if (typeof file === "string") {
            summaryContent += `- [[${file}|${file.split("/").pop()}]]
`;
          } else {
            summaryContent += `- Unknown file format
`;
          }
        });
        if (createdFilesArray.length > 10) {
          summaryContent += `- ... and ${createdFilesArray.length - 10} more files
`;
        }
        summaryContent += "\n";
      }
      const createdNotes = /* @__PURE__ */ new Map();
      const tagsTracking = /* @__PURE__ */ new Map();
      if (this.settings.tagsToTrack.length > 0) {
        this.settings.tagsToTrack.forEach((tag) => {
          tagsTracking.set(tag, /* @__PURE__ */ new Set());
        });
        const markdownFiles = this.app.vault.getMarkdownFiles();
        for (const file of markdownFiles) {
          const fileCache = this.app.metadataCache.getFileCache(file);
          if (fileCache && fileCache.tags) {
            const fileTags = fileCache.tags.map((t) => t.tag);
            for (const trackedTag of this.settings.tagsToTrack) {
              if (fileTags.includes(trackedTag)) {
                const tagSet = tagsTracking.get(trackedTag);
                if (tagSet) {
                  tagSet.add(file.path);
                }
              }
            }
          }
        }
      }
      const wordsData = dayReports.map((day) => [day.date, day.wordCount]);
      const timeData = dayReports.map((day) => [day.date, day.studyTime]);
      summaryContent += `weekly_study_time:: ${studyHours}h ${studyMinutes}m
`;
      summaryContent += `weekly_break_time:: ${breakHours}h ${breakMinutes}m
`;
      summaryContent += `weekly_total_time:: ${totalTimeHours}h ${totalTimeMinutes}m
`;
      summaryContent += `weekly_pomodoros:: ${weeklyPomodoros}
`;
      summaryContent += `weekly_words_written:: ${weeklyWordCount}
`;
      summaryContent += `weekly_modified_files:: ${modifiedFiles.size}
`;
      summaryContent += `weekly_created_files:: ${totalCreatedFiles}
`;
      summaryContent += `weekly_created_notes:: ${totalCreatedNotes}
`;
      summaryContent += `weekly_modified_notes:: ${totalModifiedNotes}
`;
      summaryContent += `weekly_created_links:: ${totalCreatedLinks}
`;
      summaryContent += `weekly_tasks_completed:: ${weeklyTasks}
`;
      summaryContent += `weekly_distractions:: ${weeklyDistractions}

`;
      if (dayReports.length > 0) {
        summaryContent += "## \u{1F4CA} Word Count Chart\n\n";
        summaryContent += "```chart\n";
        summaryContent += "type: bar\n";
        summaryContent += "labels: [" + dayReports.map((d) => `"${d.date}"`).join(", ") + "]\n";
        summaryContent += "series:\n";
        summaryContent += "  - title: Words Written\n";
        summaryContent += "    data: [" + dayReports.map((d) => d.wordCount).join(", ") + "]\n";
        summaryContent += "width: 100%\n";
        summaryContent += "labelColors: true\n";
        summaryContent += "```\n\n";
        summaryContent += "## \u23F1\uFE0F Study Time Chart\n\n";
        summaryContent += "```chart\n";
        summaryContent += "type: bar\n";
        summaryContent += "labels: [" + dayReports.map((d) => `"${d.date}"`).join(", ") + "]\n";
        summaryContent += "series:\n";
        summaryContent += "  - title: Study Minutes\n";
        summaryContent += "    data: [" + dayReports.map((d) => d.studyTime).join(", ") + "]\n";
        summaryContent += "width: 100%\n";
        summaryContent += "labelColors: true\n";
        summaryContent += "```\n\n";
        summaryContent += "## \u{1F4DD} Notes Created & Modified Chart\n\n";
        summaryContent += "```chart\n";
        summaryContent += "type: bar\n";
        summaryContent += "labels: [" + dayReports.map((d) => `"${d.date}"`).join(", ") + "]\n";
        summaryContent += "series:\n";
        summaryContent += "  - title: Notes Created\n";
        summaryContent += "    data: [" + dayReports.map((d) => d.createdNotes).join(", ") + "]\n";
        summaryContent += "  - title: Notes Modified\n";
        summaryContent += "    data: [" + dayReports.map((d) => d.modifiedNotes).join(", ") + "]\n";
        summaryContent += "width: 100%\n";
        summaryContent += "labelColors: true\n";
        summaryContent += "stacked: true\n";
        summaryContent += "```\n\n";
        if (this.settings.tagsToTrack.length > 0) {
          summaryContent += "## \u{1F3F7}\uFE0F Tracked Tags\n\n";
          for (const [tag, files] of tagsTracking.entries()) {
            summaryContent += `### ${tag} (${files.size} files)

`;
            if (files.size > 0) {
              for (const file of files) {
                summaryContent += `- [[${file}|${file.split("/").pop()}]]
`;
              }
              summaryContent += "\n";
            } else {
              summaryContent += "*No files with this tag*\n\n";
            }
          }
        }
      }
      const weeklyFileName = `${mondayStr}_weekly_summary.md`;
      const weeklyFilePath = `${this.settings.notesFolder}/${weeklyFileName}`;
      if (!await this.app.vault.adapter.exists(this.settings.notesFolder)) {
        await this.app.vault.createFolder(this.settings.notesFolder);
      }
      await this.app.vault.create(weeklyFilePath, summaryContent);
      new import_obsidian.Notice("Weekly summary created successfully!");
    } catch (error) {
      console.error("Error creating weekly summary:", error);
      new import_obsidian.Notice("Error creating weekly summary");
    }
  }
  findNewlyCompletedTasks(content, filePath) {
    const lines = content.split("\n");
    const completedTasks = [];
    lines.forEach((line) => {
      if (line.match(/^- \[([xX])\] /)) {
        const taskText = line.replace(/^- \[([xX])\] /, "");
        completedTasks.push(`${filePath}: ${taskText}`);
      }
    });
    return completedTasks;
  }
  updateStatusBar(time) {
    this.statusBarItem.setText(`\u{1F345} ${time}`);
  }
  // Auto-update category based on current folder
  updateCategoryByFolder(filePath) {
    if (!this.currentSession || this.currentSession.isBreak)
      return;
    if (Object.keys(this.settings.folderCategoryMappings).length === 0)
      return;
    const view = this.getStudyFlowView();
    if (!view)
      return;
    const folderPath = filePath.substring(0, filePath.lastIndexOf("/"));
    let bestMatch = "";
    let bestMatchCategory = "";
    for (const path in this.settings.folderCategoryMappings) {
      if (folderPath.startsWith(path) && path.length > bestMatch.length) {
        bestMatch = path;
        bestMatchCategory = this.settings.folderCategoryMappings[path];
      }
    }
    if (bestMatchCategory && this.currentSession.category !== bestMatchCategory) {
      view.changeCategory(bestMatchCategory);
    }
  }
  // Count words in text content
  countWords(text) {
    const cleanedText = text.replace(/```[\s\S]*?```/g, "").replace(/`[^`]*`/g, "").replace(/\[.*?\]\(.*?\)/g, "").replace(/\!\[.*?\]\(.*?\)/g, "").replace(/\[\[.*?\]\]/g, "").replace(/#[\w-]+/g, "").replace(/^\s*[-+*]\s+/gm, "").replace(/^\s*\d+\.\s+/gm, "").replace(/^\s*>\s+/gm, "").replace(/^#+\s+/gm, "").replace(/\*\*|\*|~~|__|_/g, "");
    return cleanedText.split(/\s+/).filter((word) => word.length > 0).length;
  }
  // Start auto-tracking when Obsidian opens
  startAutoTracking() {
    if (!this.currentSession && this.settings.autoTrackSessionOnStartup) {
      const defaultCategory = this.settings.categories.find((c) => c !== "~Break~") || "Study";
      this.startNewSession(defaultCategory);
      const view = this.getStudyFlowView();
      if (view) {
        view.categorySelect.value = defaultCategory;
        if (!view.isRunning) {
          view.startTimer();
        }
      }
      new import_obsidian.Notice(`Auto-tracking started - Category: ${defaultCategory}`);
    }
  }
  // Function to check if it's time to create the weekly summary
  async checkWeeklySummary() {
    if (!this.settings.enableWeeklySummary)
      return;
    const now = /* @__PURE__ */ new Date();
    const today = now.getDay();
    if (today === this.settings.weeklySummaryDay) {
      const lastWeeklySummaryDate = this.settings.lastWeeklySummary || "";
      const todayStr = now.toISOString().split("T")[0];
      if (lastWeeklySummaryDate !== todayStr) {
        await this.createWeeklySummary();
        this.settings.lastWeeklySummary = todayStr;
        await this.saveSettings();
      }
    }
  }
  onunload() {
    this.app.workspace.getLeavesOfType(VIEW_TYPE_STUDY_FLOW).forEach((leaf) => leaf.detach());
  }
};
